---
title: Embedding subplots in ggplot2 graphics
author: Ariel Muldoon
date: '2019-04-22'
slug: embedding-subplots
categories:
  - r
tags:
  - ggplot2
  - purrr
draft: FALSE
description: "I first learned about embedding many small subplots into a larger plot as a way to visualize large datasets with package ggsubplot.  Embedding subplots is still possible in ggplot2 today with the annotation_custom() function.  I demonstrate one approach to do this, making many subplots in a loop and then adding them to the larger plot."
---



<p>The idea of embedded plots for visualizing a large dataset that has an overplotting problem recently came up in some discussions with students. I first learned about embedded graphics from package <strong>ggsubplot</strong>. You can still see <a href="https://blog.revolutionanalytics.com/2012/09/visualize-complex-data-with-subplots.html">an old post</a> about that package and about embedded graphics in general, with examples. However, <strong>ggsubplot</strong> is no longer maintained and doesn’t work with current versions of <strong>ggplot2</strong>.</p>
<p>I poked around a bit, and found that <code>annotation_custom()</code> is the go-to function for embedding plots in a <strong>ggplot2</strong> graphic. I found a couple of recent examples for how to tackle making such plots on Stack Overflow <a href="https://stackoverflow.com/a/44125392/2461552">here</a> and <a href="https://stackoverflow.com/a/45417727/2461552">here</a>.</p>
<p>I’m going to work through an example of embedding subplots using the same kind of looping approach outlined in those answers.</p>
<div id="table-of-contents" class="section level2">
<h2>Table of Contents</h2>
<ul>
<li><a href="#r-packages">R packages</a></li>
<li><a href="#cutting-continuous-variables-into-evenly-spaced-categories">Cutting continuous variables into evenly-spaced categories</a></li>
<li><a href="#categorizing-the-axis-variables">Categorizing the axis variables</a></li>
<li><a href="#extracting-the-coordinates-for-each-subplot">Extracting the coordinates for each subplot</a></li>
<li><a href="#bar-plot-subplots">Bar plot subplots</a></li>
<li><a href="#creating-all-the-bar-plot-subplots">Creating all the bar plot subplots</a></li>
<li><a href="#putting-the-subplots-into-annotation_custom">Putting the subplots into annotation_custom()</a></li>
<li><a href="#making-the-large-plot">Making the large plot</a></li>
<li><a href="#embedding-the-bar-plot-subplots">Embedding the bar plot subplots</a></li>
<li><a href="#histogram-subplots">Histogram subplots</a></li>
<li><a href="#get-the-histograms-ready-to-embed">Get the histograms ready to embed</a></li>
<li><a href="#embed-the-histogram-subplots">Embed the histogram subplots</a></li>
<li><a href="#a-density-subplot-example">A density subplot example</a></li>
<li><a href="#filled-density-plots">Filled density plots</a></li>
<li><a href="#just-the-code-please">Just the code, please</a></li>
</ul>
</div>
<div id="r-packages" class="section level1">
<h1>R packages</h1>
<p>First I’ll load the R packages I’m using today. All plotting is done via <strong>ggplot2</strong>, I do data manipulation with <strong>dplyr</strong> and <strong>tidyr</strong>, and <strong>purrr</strong> is for looping to make the subplots and then for getting the subplots into <code>annotation_custom()</code> layers.</p>
<pre class="r"><code>library(ggplot2) # 3.1.1
suppressPackageStartupMessages( library(dplyr) ) # 0.8.0.1
library(tidyr) # 0.8.3
library(purrr) # 0.3.2</code></pre>
</div>
<div id="cutting-continuous-variables-into-evenly-spaced-categories" class="section level1">
<h1>Cutting continuous variables into evenly-spaced categories</h1>
<p>Binning the continuous variables that will be on the axes of the larger plot in order to create separate datasets for each subplot is the first step in this process.</p>
<p>I thought it made the most sense to make all the subplots the same size in the final plot and so I wanted to make evenly sized <em>bins</em> or groups. The range of values in each bin can then be based on the total range of the variable of interest and the desired number of groups.</p>
<p>Binning into even-length groups is a job for <code>cut()</code>. I’m going to need the minimum and maximum value of each group to place the subplots along the axes of the larger plot, so rather than using <code>cut()</code> directly I made a function built around it. While information on the range of values encompassed by a group can be pulled from the default <code>cut()</code> bin labels, I didn’t like how <code>cut()</code> rounded those values.</p>
<p>My function, <code>cuteven()</code>, takes a continuous variable and returns a variable cut into <code>ngroups</code> bins. The labels for the new groups are the unrounded minimum and maximum value within each group, with the values separated by commas.</p>
<p>I use <code>include.lowest = TRUE</code> in <code>cut()</code> is to make sure the minimum value in the dataset is included in the first group.</p>
<pre class="r"><code>cuteven = function(variable, ngroups) {
     seq_all = seq(min(variable), max(variable), length.out = ngroups + 1)
     cut(variable,
         breaks = seq_all,
         labels = paste(seq_all[-(ngroups + 1)], seq_all[-1], sep = &quot;,&quot;),
         include.lowest = TRUE)
}</code></pre>
<p>I’ll test the function by cutting <code>Sepal.Length</code> from the <code>iris</code> dataset into 3 groups. The new, categorical variable has three groups. The groups are labeled with their minimum and maximum value.</p>
<pre class="r"><code>with(iris, cuteven(Sepal.Length, ngroups = 3) )</code></pre>
<pre><code>#   [1] 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5
#   [9] 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 5.5,6.7 5.5,6.7
#  [17] 4.3,5.5 4.3,5.5 5.5,6.7 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5
#  [25] 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5
#  [33] 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5
#  [41] 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5 4.3,5.5
#  [49] 4.3,5.5 4.3,5.5 6.7,7.9 5.5,6.7 6.7,7.9 4.3,5.5 5.5,6.7 5.5,6.7
#  [57] 5.5,6.7 4.3,5.5 5.5,6.7 4.3,5.5 4.3,5.5 5.5,6.7 5.5,6.7 5.5,6.7
#  [65] 5.5,6.7 5.5,6.7 5.5,6.7 5.5,6.7 5.5,6.7 5.5,6.7 5.5,6.7 5.5,6.7
#  [73] 5.5,6.7 5.5,6.7 5.5,6.7 5.5,6.7 6.7,7.9 5.5,6.7 5.5,6.7 5.5,6.7
#  [81] 4.3,5.5 4.3,5.5 5.5,6.7 5.5,6.7 4.3,5.5 5.5,6.7 5.5,6.7 5.5,6.7
#  [89] 5.5,6.7 4.3,5.5 4.3,5.5 5.5,6.7 5.5,6.7 4.3,5.5 5.5,6.7 5.5,6.7
#  [97] 5.5,6.7 5.5,6.7 4.3,5.5 5.5,6.7 5.5,6.7 5.5,6.7 6.7,7.9 5.5,6.7
# [105] 5.5,6.7 6.7,7.9 4.3,5.5 6.7,7.9 5.5,6.7 6.7,7.9 5.5,6.7 5.5,6.7
# [113] 6.7,7.9 5.5,6.7 5.5,6.7 5.5,6.7 5.5,6.7 6.7,7.9 6.7,7.9 5.5,6.7
# [121] 6.7,7.9 5.5,6.7 6.7,7.9 5.5,6.7 5.5,6.7 6.7,7.9 5.5,6.7 5.5,6.7
# [129] 5.5,6.7 6.7,7.9 6.7,7.9 6.7,7.9 5.5,6.7 5.5,6.7 5.5,6.7 6.7,7.9
# [137] 5.5,6.7 5.5,6.7 5.5,6.7 6.7,7.9 5.5,6.7 6.7,7.9 5.5,6.7 6.7,7.9
# [145] 5.5,6.7 5.5,6.7 5.5,6.7 5.5,6.7 5.5,6.7 5.5,6.7
# Levels: 4.3,5.5 5.5,6.7 6.7,7.9</code></pre>
</div>
<div id="categorizing-the-axis-variables" class="section level1">
<h1>Categorizing the axis variables</h1>
<p>While these embedded plots can be useful for large datasets, I’m going demonstrate the process on a relatively small dataset. Here I will embed subplots on a larger plot based on the <code>iris</code> data. The variable <code>Sepal.Length</code> will be on the x axis and <code>Petal.Length</code> on the y axis.</p>
<p>My first step is to categorize those variables with <code>cuteven()</code>. I’m going to make three groups for <code>Sepal.Length</code> and four groups for <code>Petal.Length</code>.</p>
<p>I cut both variables within <code>mutate()</code> and add them to <code>iris</code>. I give the new variables generic names that indicate which variable is on the <code>x</code> axis and which on the <code>y</code>.</p>
<pre class="r"><code>iris = mutate(iris,
                group_x = cuteven(Sepal.Length, 3),
                group_y = cuteven(Petal.Length, 4) )

glimpse(iris)</code></pre>
<pre><code># Observations: 150
# Variables: 7
# $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9,...
# $ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1,...
# $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5,...
# $ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1,...
# $ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, s...
# $ group_x      &lt;fct&gt; &quot;4.3,5.5&quot;, &quot;4.3,5.5&quot;, &quot;4.3,5.5&quot;, &quot;4.3,5.5&quot;, &quot;4.3,...
# $ group_y      &lt;fct&gt; &quot;1,2.475&quot;, &quot;1,2.475&quot;, &quot;1,2.475&quot;, &quot;1,2.475&quot;, &quot;1,2....</code></pre>
</div>
<div id="extracting-the-coordinates-for-each-subplot" class="section level1">
<h1>Extracting the coordinates for each subplot</h1>
<p>I need the minimum and maximum value per group for each axis variable in order to place the subplot in the larger plot with <code>annotation_custom()</code>. Since the labels of the new variables contain this info separated by a comma, I can use <code>separate()</code> to extract the coordinate information from the labels into separate columns.</p>
<p>Since I have two group variables, one for each axis, I end up using <code>separate()</code> twice. I again make the names of the new columns in <code>into</code> based on which axis I’ll be plotting that variable on.</p>
<p>When this step is complete I’ll have coordinates to indicate where each corner of a subplot will be placed within the larger plot. Unique combinations of the four coordinate variables define each group I want to make a subplot for.</p>
<pre class="r"><code>iris = iris %&gt;%
     separate(group_x, into = c(&quot;min_x&quot;, &quot;max_x&quot;), 
              sep = &quot;,&quot;, convert = TRUE) %&gt;%
     separate(group_y, into = c(&quot;min_y&quot;, &quot;max_y&quot;), 
              sep = &quot;,&quot;, convert = TRUE)

glimpse(iris)</code></pre>
<pre><code># Observations: 150
# Variables: 9
# $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9,...
# $ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1,...
# $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5,...
# $ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1,...
# $ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, s...
# $ min_x        &lt;dbl&gt; 4.3, 4.3, 4.3, 4.3, 4.3, 4.3, 4.3, 4.3, 4.3, 4.3,...
# $ max_x        &lt;dbl&gt; 5.5, 5.5, 5.5, 5.5, 5.5, 5.5, 5.5, 5.5, 5.5, 5.5,...
# $ min_y        &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1...
# $ max_y        &lt;dbl&gt; 2.475, 2.475, 2.475, 2.475, 2.475, 2.475, 2.475, ...</code></pre>
</div>
<div id="bar-plot-subplots" class="section level1">
<h1>Bar plot subplots</h1>
<p>Next I’m going to figure out what I want my subplots to look like. I’m going to start with bar plots to count up the number of each species in each group.</p>
<p>Since I will be making many similar plots I’ll create a function to use for the plotting. I always work out what I want the plot to look like on a single subset of the data before making the function.</p>
<p>In this case, I want all the plots to have the same x and y axes. The y axis of my bar plot is based on counts, so I need to calculate the maximum number of species across groups so I can set the upper y axis limit for all plots to that value.</p>
<p>The maximum count is <code>47</code>, so that will be my upper axis limit. Bar plots start at <code>0</code>.</p>
<pre class="r"><code>iris %&gt;%
     group_by(min_x, max_x, min_y, max_y, Species) %&gt;%
     count() %&gt;%
     ungroup() %&gt;%
     filter(n == max(n) )</code></pre>
<pre><code># # A tibble: 1 x 6
#   min_x max_x min_y max_y Species     n
#   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;   &lt;int&gt;
# 1   4.3   5.5     1  2.48 setosa     47</code></pre>
<p>In case a species is missing from one of the subplot groups I’ll define the <code>limits</code> for the x axis in <code>scale_x_discrete()</code>. This forces each plot to have the same x axis breaks.</p>
<p>I’ll be removing all axis labels, etc., via <code>theme_void()</code> so that the subplots fit nicely into the larger plot. I will add an outline around the plot, though.</p>
<p>I use <code>fill</code> to color the bars by species since there will be no x axis labels on the subplots. I suppress the legend, as well, and will add a legend to the large plot instead.</p>
<p>I set explicit colors in <code>scale_fill_manual()</code> (colors taken <a href="http://colorspace.r-forge.r-project.org/articles/hcl_palettes.html#qualitative-palettes">from here</a>) so all the subplots will have the same color scheme.</p>
<p>Here is my test plot for one group. This particular group only has one species in it.</p>
<pre class="r"><code>ggplot(data = filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475), 
       aes(x = Species, fill = Species) ) +
     geom_bar() +
     theme_void() +
     scale_x_discrete(limits = c(&quot;setosa&quot;, &quot;versicolor&quot;, &quot;virginica&quot;) ) +
     scale_fill_manual(values = c(&quot;setosa&quot; = &quot;#ED90A4&quot;, 
                                  &quot;versicolor&quot; = &quot;#ABB150&quot;,
                                  &quot;virginica&quot; = &quot;#00C1B2&quot;),
                       guide  = &quot;none&quot;) +
     theme(panel.border = element_rect(color = &quot;grey&quot;,
                                       fill = &quot;transparent&quot;) ) +
     ylim(0, 47)</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>Once I have the plot worked out for one group I put the code into a function, <code>barfun</code>. In this case the function takes only a dataset, since I’m hard-coding in all the axis variables, limits, etc.</p>
<pre class="r"><code>barfun = function(data) {
     ggplot(data = data, 
            aes(x = Species, fill = Species) ) +
          geom_bar() +
          theme_void() +
          scale_x_discrete(limits = c(&quot;setosa&quot;, &quot;versicolor&quot;, &quot;virginica&quot;) ) +
          scale_fill_manual(values = c(&quot;setosa&quot; = &quot;#ED90A4&quot;, 
                                       &quot;versicolor&quot; = &quot;#ABB150&quot;,
                                       &quot;virginica&quot; = &quot;#00C1B2&quot;),
                            guide  = &quot;none&quot;) +
          theme(panel.border = element_rect(color = &quot;grey&quot;,
                                            fill = &quot;transparent&quot;) ) +
          ylim(0, 47) 
  
}</code></pre>
<p>Does this function make the same plot I made manually? Yep. 👍</p>
<pre class="r"><code>barfun(data = filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475) )</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
</div>
<div id="creating-all-the-bar-plot-subplots" class="section level1">
<h1>Creating all the bar plot subplots</h1>
<p>I’m ready to make the subplots!</p>
<p>I’ll loop through each subset of data and plot it with my function.</p>
<p>Since I’m going to need those coordinates for subplot placement later I decided that the most straightforward way to do this is to group by the unique combinations of coordinates and then <em>nest</em> the dataset. When nesting, the data to be plotted for each group is placed in a column called <code>data</code>.</p>
<p>I loop through each dataset in <code>data</code> via <code>map()</code> within <code>mutate()</code>. The new column containing the plots is named <code>subplots</code>.</p>
<pre class="r"><code>allplots = iris %&gt;%
     group_by_at( vars( matches(&quot;min|max&quot;) ) ) %&gt;%
     group_nest() %&gt;%
     mutate(subplots = map(data, barfun) )

allplots</code></pre>
<pre><code># # A tibble: 9 x 6
#   min_x max_x min_y max_y data              subplots
#   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt;            &lt;list&gt;  
# 1   4.3   5.5  1     2.48 &lt;tibble [47 x 5]&gt; &lt;S3: gg&gt;
# 2   4.3   5.5  2.48  3.95 &lt;tibble [7 x 5]&gt;  &lt;S3: gg&gt;
# 3   4.3   5.5  3.95  5.42 &lt;tibble [5 x 5]&gt;  &lt;S3: gg&gt;
# 4   5.5   6.7  1     2.48 &lt;tibble [3 x 5]&gt;  &lt;S3: gg&gt;
# 5   5.5   6.7  2.48  3.95 &lt;tibble [4 x 5]&gt;  &lt;S3: gg&gt;
# 6   5.5   6.7  3.95  5.42 &lt;tibble [51 x 5]&gt; &lt;S3: gg&gt;
# 7   5.5   6.7  5.42  6.9  &lt;tibble [13 x 5]&gt; &lt;S3: gg&gt;
# 8   6.7   7.9  3.95  5.42 &lt;tibble [5 x 5]&gt;  &lt;S3: gg&gt;
# 9   6.7   7.9  5.42  6.9  &lt;tibble [15 x 5]&gt; &lt;S3: gg&gt;</code></pre>
<p>Here’s a couple of the plots. The first one should look familiar.</p>
<pre class="r"><code>allplots$subplots[[1]]</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r"><code>allplots$subplots[[6]]</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-11-2.png" width="672" /></p>
</div>
<div id="putting-the-subplots-into-annotation_custom" class="section level1">
<h1>Putting the subplots into annotation_custom()</h1>
<p>Next I need to make each of these plots a <em>grob</em> (graphical object) and pass it into <code>annotation_custom()</code>. The coordinates for each subplot will be passed to the <code>xmin</code>, <code>xmax</code>, <code>ymin</code>, <code>ymax</code> arguments in <code>annotation_custom()</code>, which indicate where each subplot should be placed in the larger plot.</p>
<p>Since I want to pass the <code>subplots</code> column as well as the four coordinates columns to <code>annotation_custom()</code> I will loop through <code>allplots</code> <em>row-wise</em>. I can use the <code>pmap()</code> function for looping through the rows of a dataset.</p>
<p>Since I’ll be working with five columns simultaneously in this step I decided to make a function prior to looping, which I name <code>grobfun</code>.</p>
<p>Notice I put my arguments of the function in the same order as they appear in the dataset and <em>they have the same names as the columns of the dataset</em>. I did this on purpose for ease of working with <code>pmap()</code>.</p>
<pre class="r"><code>grobfun = function(min_x, max_x, min_y, max_y, subplots) {
     annotation_custom(ggplotGrob(subplots),
                       xmin = min_x, ymin = min_y,
                       xmax = max_x, ymax = max_y)
}</code></pre>
<p>I no longer need the <code>data</code> column, so I remove it to end up with only the columns I need to pass to the <code>grobfun()</code> function. This isn’t strictly necessary, but I find it makes working with <code>pmap()</code> easier.</p>
<p>The dot, <code>.</code>, indicates I’m passing the entire dataset to <code>pmap()</code> and so looping through it row-wise.</p>
<p>I find this can take a little time to run when doing many subplots.</p>
<pre class="r"><code>( allgrobs = allplots %&gt;%
     select(-data) %&gt;%
     mutate(grobs = pmap(., grobfun) ) )</code></pre>
<pre><code># # A tibble: 9 x 6
#   min_x max_x min_y max_y subplots grobs              
#   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt;   &lt;list&gt;             
# 1   4.3   5.5  1     2.48 &lt;S3: gg&gt; &lt;S3: LayerInstance&gt;
# 2   4.3   5.5  2.48  3.95 &lt;S3: gg&gt; &lt;S3: LayerInstance&gt;
# 3   4.3   5.5  3.95  5.42 &lt;S3: gg&gt; &lt;S3: LayerInstance&gt;
# 4   5.5   6.7  1     2.48 &lt;S3: gg&gt; &lt;S3: LayerInstance&gt;
# 5   5.5   6.7  2.48  3.95 &lt;S3: gg&gt; &lt;S3: LayerInstance&gt;
# 6   5.5   6.7  3.95  5.42 &lt;S3: gg&gt; &lt;S3: LayerInstance&gt;
# 7   5.5   6.7  5.42  6.9  &lt;S3: gg&gt; &lt;S3: LayerInstance&gt;
# 8   6.7   7.9  3.95  5.42 &lt;S3: gg&gt; &lt;S3: LayerInstance&gt;
# 9   6.7   7.9  5.42  6.9  &lt;S3: gg&gt; &lt;S3: LayerInstance&gt;</code></pre>
</div>
<div id="making-the-large-plot" class="section level1">
<h1>Making the large plot</h1>
<p>I haven’t actually made the larger plot I’m going to embed subplots into yet. This will be a blank plot with <code>Sepal.Length</code> on the x axis and <code>Petal.Length</code> on the y axis with a legend for <code>fill</code>.</p>
<p>Adding on the overall legend to a blank plot involves a little trick with <code>geom_col()</code>, which was demonstrated in those Stack Overflow posts. (Thank goodness for SO, since I would have never figured it out otherwise 😜.)</p>
<p>Here is the plot I will embed the subplots into.</p>
<pre class="r"><code>( largeplot = ggplot(iris, aes(x = Sepal.Length, 
                               y = Petal.Length, 
                               fill = Species) ) +
       geom_blank() +
       geom_col( aes(Inf, Inf) ) +
       scale_fill_manual(values = c(&quot;setosa&quot; = &quot;#ED90A4&quot;, 
                                    &quot;versicolor&quot; = &quot;#ABB150&quot;,
                                    &quot;virginica&quot; = &quot;#00C1B2&quot;) ) )</code></pre>
<pre><code># Warning: Removed 149 rows containing missing values (geom_col).</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
</div>
<div id="embedding-the-bar-plot-subplots" class="section level1">
<h1>Embedding the bar plot subplots</h1>
<p>Last step! I can now add the list of subplots in <code>annotation_custom()</code> to the larger plot. 🎉</p>
<p>There was a little extra space on the y axis that I removed by setting the axis limits.</p>
<p>I think this looks nice with evenly spaced subplots but there may be times that having unevenly spaced subplots is desirable. In that case you could cut the variables into uneven groups.</p>
<pre class="r"><code>largeplot +
     allgrobs$grobs +
     ylim(1, NA)</code></pre>
<pre><code># Warning: Removed 150 rows containing missing values (geom_col).</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>After polishing this plot up a bit as desired, the final plot can be saved with <code>ggsave()</code>.</p>
</div>
<div id="histogram-subplots" class="section level1">
<h1>Histogram subplots</h1>
<p>I’ve seen quite a few examples of embedded plots with bar plot or pie chart subplots to show patterns in the distribution of some categorical variable across the axis variables. But there’s no reason we can’t show the distribution of a third continuous variable.</p>
<p>I decided to make a histogram of the variable <code>Petal.Width</code> for the same subplot groups I used above. I found a lot of little details to work through when making subplots showing the distribution of a continuous variable.</p>
<p>I want the x axis of each plot to encompass the entire range of <code>Petal.Width</code>, so my first step was to pull out that information. These values will be the x axis limits (with some extra added to make sure all the histogram bars fit) and the limits for the continuous legend.</p>
<pre class="r"><code>range(iris$Petal.Width)</code></pre>
<pre><code># [1] 0.1 2.5</code></pre>
<p>I found the y axis to be a little trickier. I decided to show the bars as proportions of the maximum count with <code>ncount</code> instead of as a raw count. Since the height of bars is then a proportion of maximum instead of a count I added the sample size per group to the plot as text. I ended up putting this in a facet strip rather than within the plot. I went back and forth a bunch and am still not sure the final result is exactly what I want.</p>
<p>I’ll base the color of the bars on <code>Petal.Width</code>. This can be done with <code>fill = stat(x)</code>, which is how to refer to the bins calculated by <code>geom_histogram()</code>.</p>
<p>To make sure each plot has the same number of bar I set the <code>binwidth</code>. I chose to make each bar 0.2 units wide, since the entire range of <code>Petal.Width</code> (2.4 units) is evenly divisible by that number. I also <code>center</code> the first bar at the minimum value of the dataset, so the first bar is centered at 0.1.</p>
<p>I pad the x axis limits with half the <code>binwidth</code> value to make sure all the bars will show in every plot. Getting the limits correct can be hard; see, e.g., <a href="https://github.com/tidyverse/ggplot2/issues/3265">this GitHub issue</a> if you are seeing warnings that you don’t think are correct.</p>
<p>Here is my example plot for the first group. Since I was careful with my plot limits the warning message is spurious.</p>
<pre class="r"><code>ggplot(data = filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475),
       aes(x = Petal.Width, y = stat(ncount), fill = stat(x) ) ) +
     geom_histogram(binwidth = .2, center = .1) +
     theme_void(base_size = 14) +
     scale_x_continuous(limits = c(0.1 - .1, 2.5 + .1) ) +
     scale_fill_continuous(type = &quot;viridis&quot;,
                           guide  = &quot;none&quot;,
                           limits = c(.1, 2.5) ) +
     facet_wrap(~paste0(&quot;n = &quot;, nrow(filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475) ) ) ) +
     theme(panel.border = element_rect(color = &quot;grey&quot;,
                                       fill = &quot;transparent&quot;) )</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p>And here’s the function to make histograms for each subplot dataset, which I name <code>histfun</code>.</p>
<pre class="r"><code>histfun = function(data) {
     ggplot(data = data,
            aes(x = Petal.Width, y = stat(ncount), fill = stat(x) ) ) +
          geom_histogram(binwidth = .2, center = .1) +
          theme_void(base_size = 14) +
          scale_x_continuous(limits = c(0.1 - .1, 2.5 + .1) ) +
          scale_fill_continuous(type = &quot;viridis&quot;,
                                guide  = &quot;none&quot;,
                                limits = c(.1, 2.5) ) +
          facet_wrap(~paste0(&quot;n = &quot;, nrow(data) ) ) +
          theme(panel.border = element_rect(color = &quot;grey&quot;,
                                            fill = &quot;transparent&quot;) )
}</code></pre>
</div>
<div id="get-the-histograms-ready-to-embed" class="section level1">
<h1>Get the histograms ready to embed</h1>
<p>This time I’ll make the subplots with <code>histfun</code> and then put them into <code>annotation_custom()</code> with <code>grobfun</code> in one pipe chain.</p>
<pre class="r"><code>allgrobs_hist = iris %&gt;%
     group_by_at( vars( matches(&quot;min|max&quot;) ) ) %&gt;%
     group_nest() %&gt;%
     mutate(subplots = map(data, histfun) ) %&gt;%
     select(-data) %&gt;%
     mutate(grobs = pmap(., grobfun) )</code></pre>
</div>
<div id="embed-the-histogram-subplots" class="section level1">
<h1>Embed the histogram subplots</h1>
<p>This time the large plot needs a continuous legend. I set the <code>breaks</code> so the minimum and maximum value are included on the legend. How well this works will depend on the range of your dataset.</p>
<pre class="r"><code>( largeplot2 = ggplot(iris, aes(x = Sepal.Length, 
                                y = Petal.Length, 
                                fill = Petal.Width) ) +
       geom_blank() +
       geom_col( aes(Inf, Inf) ) +
       scale_fill_continuous(type = &quot;viridis&quot;,
                             limits = c(.1, 2.5),
                             breaks = seq(.1, 2.5, by = .8) ) )</code></pre>
<pre><code># Warning: Removed 149 rows containing missing values (geom_col).</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>And, finally, here’s the plot embedded with the <code>Petal.Width</code> distribution plots. 😃</p>
<pre class="r"><code>largeplot2 +
     allgrobs_hist$grobs +
     ylim(1, NA)</code></pre>
<pre><code># Warning: Removed 150 rows containing missing values (geom_col).</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
</div>
<div id="a-density-subplot-example" class="section level1">
<h1>A density subplot example</h1>
<p>I thought the histogram subplots ended up being pretty tricky, what with having to figure out the plot limits and the bar widths and centers.</p>
<p>Density plots are another possibility for showing the distribution of continuous data, and the color of the line can be allowed to vary.</p>
<p>Here’s an example of what a density plot could look like. In some scenarios using <code>trim = TRUE</code> may be useful in <code>stat_density()</code>. You’ll notice I set the x axis limits to the minimum and maximum value in the datast with no padding for this plot.</p>
<pre class="r"><code>ggplot(data = filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475),
       aes(x = Petal.Width, y = stat(ndensity), color = stat(x) ) ) +
     stat_density(geom = &quot;line&quot;, size = 1.25) +
     theme_void(base_size = 14) +
     scale_x_continuous(limits = c(0.1, 2.5),
                        expand = c(0, 0) ) +
     scale_color_viridis_c(guide  = &quot;none&quot;,
                           limits = c(.1, 2.5) ) +
     facet_wrap(~paste0(&quot;n = &quot;, nrow(filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475) ) ) ) +
     theme(panel.border = element_rect(color = &quot;grey&quot;,
                                       fill = &quot;transparent&quot;) )</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<p>Turning the plot code into a function for looping through groups.</p>
<pre class="r"><code>densfun = function(data) {
     ggplot(data = data,
            aes(x = Petal.Width, y = stat(ndensity), color = stat(x) ) ) +
          stat_density(geom = &quot;line&quot;, size = 1.25) +
          theme_void(base_size = 14) +
          scale_x_continuous(limits = c(0.1, 2.5),
                             expand = c(0, 0) ) +
          scale_color_viridis_c(guide  = &quot;none&quot;,
                                limits = c(.1, 2.5) ) +
          facet_wrap(~paste0(&quot;n = &quot;, nrow(data) ) ) +
          theme(panel.border = element_rect(color = &quot;grey&quot;,
                                            fill = &quot;transparent&quot;) )
}</code></pre>
<p>Loop through to create and get the subplots ready to add to the plot.</p>
<pre class="r"><code>allgrobs_dens = iris %&gt;%
     group_by_at( vars( matches(&quot;min|max&quot;) ) ) %&gt;%
     group_nest() %&gt;%
     mutate(subplots = map(data, densfun) ) %&gt;%
     select(-data) %&gt;%
     mutate(grobs = pmap(., grobfun) )</code></pre>
<p>And here’s the density subplots embedded in the large plot. Not too bad! I’m guessing the density plot approach would be most useful for larger sample sizes. 😺</p>
<pre class="r"><code>largeplot2 +
     allgrobs_dens$grobs +
     ylim(1, NA)</code></pre>
<pre><code># Warning: Removed 150 rows containing missing values (geom_col).</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
</div>
<div id="filled-density-plots" class="section level1">
<h1>Filled density plots</h1>
<p>I belatedly realized that we can use <code>geom_density_ridges_gradient()</code> from package <strong>ggridges</strong> to make density plots with continuous fill.</p>
<p>Since this package is really for <a href="https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html">ridge plots</a>, I use <code>y = 1</code> to get a single density plot. This geom uses a relative scale by default so <code>stat(ndensity)</code> isn’t needed.</p>
<pre class="r"><code>library(ggridges) # v 0.5.1
ggplot(data = filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475),
       aes(x = Petal.Width, y = 1, fill = stat(x) ) ) +
     geom_density_ridges_gradient() +
     theme_void(base_size = 14) +
     scale_x_continuous(limits = c(0.1, 2.5),
                        expand = c(0, 0) ) +
     scale_fill_viridis_c(guide  = &quot;none&quot;,
                           limits = c(.1, 2.5) ) +
     facet_wrap(~paste0(&quot;n = &quot;, nrow(filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475) ) ) ) +
     theme(panel.border = element_rect(color = &quot;grey&quot;,
                                       fill = &quot;transparent&quot;) )</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<p>Let’s see how that looks as embedded plots. I’ll do the whole process in one code chunk, taking some extra time to move the legend around in the final plot.</p>
<pre class="r"><code>densfun2 = function(data) {
  ggplot(data = data,
         aes(x = Petal.Width, y = 1, fill = stat(x) ) ) +
    geom_density_ridges_gradient() +
    theme_void(base_size = 14) +
    scale_x_continuous(limits = c(0.1, 2.5),
                       expand = c(0, 0) ) +
    scale_fill_viridis_c(guide  = &quot;none&quot;,
                         limits = c(.1, 2.5) ) +
    facet_wrap(~paste0(&quot;n = &quot;, nrow(data) ) ) +
    theme(panel.border = element_rect(color = &quot;grey&quot;,
                                      fill = &quot;transparent&quot;) )
}
allgrobs_dens2 = iris %&gt;%
    group_by_at( vars( matches(&quot;min|max&quot;) ) ) %&gt;%
    group_nest() %&gt;%
    mutate(subplots = map(data, densfun2) ) %&gt;%
    select(-data) %&gt;%
    mutate(grobs = pmap(., grobfun) )

largeplot2 +
    allgrobs_dens2$grobs +
    ylim(1, NA) +
    theme_bw() +
    theme(legend.direction = &quot;horizontal&quot;,
          legend.position = c(.8, .25),
          legend.background = element_blank() ) +
    guides(fill = guide_colorbar(title.position = &quot;top&quot;) )</code></pre>
<pre><code># Warning: Removed 150 rows containing missing values (geom_col).</code></pre>
<p><img src="/post/2019-04-22-embedding-subplots_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
</div>
<div id="just-the-code-please" class="section level1">
<h1>Just the code, please</h1>
<p>Here’s the code without all the discussion.</p>
<pre class="r"><code>library(ggplot2) # 3.1.1
suppressPackageStartupMessages( library(dplyr) ) # 0.8.0.1
library(tidyr) # 0.8.3
library(purrr) # 0.3.2

cuteven = function(variable, ngroups) {
     seq_all = seq(min(variable), max(variable), length.out = ngroups + 1)
     cut(variable,
         breaks = seq_all,
         labels = paste(seq_all[-(ngroups + 1)], seq_all[-1], sep = &quot;,&quot;),
         include.lowest = TRUE)
}

with(iris, cuteven(Sepal.Length, ngroups = 3) )

iris = mutate(iris,
                group_x = cuteven(Sepal.Length, 3),
                group_y = cuteven(Petal.Length, 4) )

glimpse(iris)

iris = iris %&gt;%
     separate(group_x, into = c(&quot;min_x&quot;, &quot;max_x&quot;), 
              sep = &quot;,&quot;, convert = TRUE) %&gt;%
     separate(group_y, into = c(&quot;min_y&quot;, &quot;max_y&quot;), 
              sep = &quot;,&quot;, convert = TRUE)

glimpse(iris)

iris %&gt;%
     group_by(min_x, max_x, min_y, max_y, Species) %&gt;%
     count() %&gt;%
     ungroup() %&gt;%
     filter(n == max(n) )

ggplot(data = filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475), 
       aes(x = Species, fill = Species) ) +
     geom_bar() +
     theme_void() +
     scale_x_discrete(limits = c(&quot;setosa&quot;, &quot;versicolor&quot;, &quot;virginica&quot;) ) +
     scale_fill_manual(values = c(&quot;setosa&quot; = &quot;#ED90A4&quot;, 
                                  &quot;versicolor&quot; = &quot;#ABB150&quot;,
                                  &quot;virginica&quot; = &quot;#00C1B2&quot;),
                       guide  = &quot;none&quot;) +
     theme(panel.border = element_rect(color = &quot;grey&quot;,
                                       fill = &quot;transparent&quot;) ) +
     ylim(0, 47)

barfun = function(data) {
     ggplot(data = data, 
            aes(x = Species, fill = Species) ) +
          geom_bar() +
          theme_void() +
          scale_x_discrete(limits = c(&quot;setosa&quot;, &quot;versicolor&quot;, &quot;virginica&quot;) ) +
          scale_fill_manual(values = c(&quot;setosa&quot; = &quot;#ED90A4&quot;, 
                                       &quot;versicolor&quot; = &quot;#ABB150&quot;,
                                       &quot;virginica&quot; = &quot;#00C1B2&quot;),
                            guide  = &quot;none&quot;) +
          theme(panel.border = element_rect(color = &quot;grey&quot;,
                                            fill = &quot;transparent&quot;) ) +
          ylim(0, 47) 
  
}
barfun(data = filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475) )

allplots = iris %&gt;%
     group_by_at( vars( matches(&quot;min|max&quot;) ) ) %&gt;%
     group_nest() %&gt;%
     mutate(subplots = map(data, barfun) )

allplots
allplots$subplots[[1]]
allplots$subplots[[6]]
grobfun = function(min_x, max_x, min_y, max_y, subplots) {
     annotation_custom(ggplotGrob(subplots),
                       xmin = min_x, ymin = min_y,
                       xmax = max_x, ymax = max_y)
}

( allgrobs = allplots %&gt;%
     select(-data) %&gt;%
     mutate(grobs = pmap(., grobfun) ) )

( largeplot = ggplot(iris, aes(x = Sepal.Length, 
                               y = Petal.Length, 
                               fill = Species) ) +
       geom_blank() +
       geom_col( aes(Inf, Inf) ) +
       scale_fill_manual(values = c(&quot;setosa&quot; = &quot;#ED90A4&quot;, 
                                    &quot;versicolor&quot; = &quot;#ABB150&quot;,
                                    &quot;virginica&quot; = &quot;#00C1B2&quot;) ) )

largeplot +
     allgrobs$grobs +
     ylim(1, NA)

range(iris$Petal.Width)

ggplot(data = filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475),
       aes(x = Petal.Width, y = stat(ncount), fill = stat(x) ) ) +
     geom_histogram(binwidth = .2, center = .1) +
     theme_void(base_size = 14) +
     scale_x_continuous(limits = c(0.1 - .1, 2.5 + .1) ) +
     scale_fill_continuous(type = &quot;viridis&quot;,
                           guide  = &quot;none&quot;,
                           limits = c(.1, 2.5) ) +
     facet_wrap(~paste0(&quot;n = &quot;, nrow(filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475) ) ) ) +
     theme(panel.border = element_rect(color = &quot;grey&quot;,
                                       fill = &quot;transparent&quot;) )

histfun = function(data) {
     ggplot(data = data,
            aes(x = Petal.Width, y = stat(ncount), fill = stat(x) ) ) +
          geom_histogram(binwidth = .2, center = .1) +
          theme_void(base_size = 14) +
          scale_x_continuous(limits = c(0.1 - .1, 2.5 + .1) ) +
          scale_fill_continuous(type = &quot;viridis&quot;,
                                guide  = &quot;none&quot;,
                                limits = c(.1, 2.5) ) +
          facet_wrap(~paste0(&quot;n = &quot;, nrow(data) ) ) +
          theme(panel.border = element_rect(color = &quot;grey&quot;,
                                            fill = &quot;transparent&quot;) )
}

allgrobs_hist = iris %&gt;%
     group_by_at( vars( matches(&quot;min|max&quot;) ) ) %&gt;%
     group_nest() %&gt;%
     mutate(subplots = map(data, histfun) ) %&gt;%
     select(-data) %&gt;%
     mutate(grobs = pmap(., grobfun) )

( largeplot2 = ggplot(iris, aes(x = Sepal.Length, 
                                y = Petal.Length, 
                                fill = Petal.Width) ) +
       geom_blank() +
       geom_col( aes(Inf, Inf) ) +
       scale_fill_continuous(type = &quot;viridis&quot;,
                             limits = c(.1, 2.5),
                             breaks = seq(.1, 2.5, by = .8) ) )

largeplot2 +
     allgrobs_hist$grobs +
     ylim(1, NA)

ggplot(data = filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475),
       aes(x = Petal.Width, y = stat(ndensity), color = stat(x) ) ) +
     stat_density(geom = &quot;line&quot;, size = 1.25) +
     theme_void(base_size = 14) +
     scale_x_continuous(limits = c(0.1, 2.5),
                        expand = c(0, 0) ) +
     scale_color_viridis_c(guide  = &quot;none&quot;,
                           limits = c(.1, 2.5) ) +
     facet_wrap(~paste0(&quot;n = &quot;, nrow(filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475) ) ) ) +
     theme(panel.border = element_rect(color = &quot;grey&quot;,
                                       fill = &quot;transparent&quot;) )

densfun = function(data) {
     ggplot(data = data,
            aes(x = Petal.Width, y = stat(ndensity), color = stat(x) ) ) +
          stat_density(geom = &quot;line&quot;, size = 1.25) +
          theme_void(base_size = 14) +
          scale_x_continuous(limits = c(0.1, 2.5),
                             expand = c(0, 0) ) +
          scale_color_viridis_c(guide  = &quot;none&quot;,
                                limits = c(.1, 2.5) ) +
          facet_wrap(~paste0(&quot;n = &quot;, nrow(data) ) ) +
          theme(panel.border = element_rect(color = &quot;grey&quot;,
                                            fill = &quot;transparent&quot;) )
}

allgrobs_dens = iris %&gt;%
     group_by_at( vars( matches(&quot;min|max&quot;) ) ) %&gt;%
     group_nest() %&gt;%
     mutate(subplots = map(data, densfun) ) %&gt;%
     select(-data) %&gt;%
     mutate(grobs = pmap(., grobfun) )
largeplot2 +
     allgrobs_dens$grobs +
     ylim(1, NA)

library(ggridges) # v 0.5.1
ggplot(data = filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475),
       aes(x = Petal.Width, y = 1, fill = stat(x) ) ) +
     geom_density_ridges_gradient() +
     theme_void(base_size = 14) +
     scale_x_continuous(limits = c(0.1, 2.5),
                        expand = c(0, 0) ) +
     scale_fill_viridis_c(guide  = &quot;none&quot;,
                           limits = c(.1, 2.5) ) +
     facet_wrap(~paste0(&quot;n = &quot;, nrow(filter(iris, max_x &lt;= 5.5, max_y &lt;= 2.475) ) ) ) +
     theme(panel.border = element_rect(color = &quot;grey&quot;,
                                       fill = &quot;transparent&quot;) )

densfun2 = function(data) {
  ggplot(data = data,
         aes(x = Petal.Width, y = 1, fill = stat(x) ) ) +
    geom_density_ridges_gradient() +
    theme_void(base_size = 14) +
    scale_x_continuous(limits = c(0.1, 2.5),
                       expand = c(0, 0) ) +
    scale_fill_viridis_c(guide  = &quot;none&quot;,
                         limits = c(.1, 2.5) ) +
    facet_wrap(~paste0(&quot;n = &quot;, nrow(data) ) ) +
    theme(panel.border = element_rect(color = &quot;grey&quot;,
                                      fill = &quot;transparent&quot;) )
}
allgrobs_dens2 = iris %&gt;%
    group_by_at( vars( matches(&quot;min|max&quot;) ) ) %&gt;%
    group_nest() %&gt;%
    mutate(subplots = map(data, densfun2) ) %&gt;%
    select(-data) %&gt;%
    mutate(grobs = pmap(., grobfun) )

largeplot2 +
    allgrobs_dens2$grobs +
    ylim(1, NA) +
    theme_bw() +
    theme(legend.direction = &quot;horizontal&quot;,
          legend.position = c(.8, .25),
          legend.background = element_blank() ) +
    guides(fill = guide_colorbar(title.position = &quot;top&quot;) )</code></pre>
</div>
