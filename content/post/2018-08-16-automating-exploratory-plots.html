---
title: Automating exploratory plots with ggplot2 and purrr
author: Ariel Muldoon
date: '2018-08-16'
slug: automating-exploratory-plots
categories:
  - r
tags:
  - ggplot2
  - purrr
draft: TRUE
description: "I show an example of how to automate the process of making many exploratory plots in ggplot2 with multiple continuous response and explanatory variables.  To loop through both x and y variables involves nested looping.  I also spend time reviewing the options for saving the results, either individually in a single document, separately, or by combing plots together into one prior to saving."
---



<p>There have been plenty of times in my own work where I‚Äôve had a lot of variables and needed to make many exploratory plots. I‚Äôve found it‚Äôs usually worthwhile to automate the process in R instead of manually copying and pasting code for every single plot.</p>
<p>However, the coding approach needed to automate plots can look pretty daunting to a beginner R user. It can look so daunting, in fact, that it can appear easier to manually make the plots (like in Excel) rather than using R.</p>
<p>Unfortunately making plots manually can backfire, as the efficiency of using a software program you already know is quickly out-weighed by being unable to easily reproduce the plots. I know I invariably have to re-make even exploratory plots, and I don‚Äôt think my experience is unusual.</p>
<p>So while I often assure students working under time constraints that it is perfectly OK to use software they already know rather than spending the time to learn how to do something in R, making plots is a special case. I like to students who need to automate plotting in R by providing code with fairly detailed explanation to get them started.</p>
<p>This post is based on an example I was working on recently, which involves plotting bivariate relationships between many continuous variables.</p>
<div id="load-r-packages" class="section level1">
<h1>Load R packages</h1>
<p>I‚Äôll be plotting with <strong>ggplot2</strong> and looping with <strong>purrr</strong>. I‚Äôll also be using package <strong>cowplot</strong> later to combine individual plots into one, but will use the package functions using <code>cowplot::</code> instead of loading the package.</p>
<pre class="r"><code>library(ggplot2) # v. 3.0.0
library(purrr) # v. 0.2.5</code></pre>
</div>
<div id="the-set-up" class="section level1">
<h1>The set-up</h1>
<p>Today I‚Äôm going to make an example dataset with 3 response (<code>y</code>) variables and 4 explanatory (<code>x</code>) variables.</p>
<pre class="r"><code>set.seed(16)
dat = data.frame(elev = round( runif(20, 100, 500), 1),
                 resp = round( runif(20, 0, 10), 1),
                 grad = round( runif(20, 0, 1), 2),
                 slp = round( runif(20, 0, 35),1),
                 lat = runif(20, 44.5, 45),
                 long = runif(20, 122.5, 123.1),
                 nt = rpois(20, lambda = 25) )
head(dat)</code></pre>
<pre><code>#    elev resp grad  slp      lat     long nt
# 1 373.2  9.7 0.05  8.8 44.54626 122.8547 18
# 2 197.6  8.1 0.42 33.3 44.79495 122.5471 26
# 3 280.0  5.4 0.38 19.3 44.99027 122.9645 18
# 4 191.8  4.3 0.07 29.6 44.95022 122.7290 19
# 5 445.4  2.3 0.43 16.5 44.79784 122.9836 15
# 6 224.5  6.5 0.78  4.1 44.96576 122.9836 21</code></pre>
<p>As you can see, every variable is in a separate column. The goal is to make scatterplots for every response variable vs every explanatory variable. I‚Äôve deemed the first three variables in the dataset to be the response variables.</p>
<p>In order to automate things I‚Äôm going to need vectors of the variable names to loop through, one vector for the response variables and one for the explanatory variables. If all of your response or explanatory variables share some unique pattern in the name there are some clever ways to pull out the names with some of the select helper functions in <code>dplyr::select()</code>. Alas, my variable names are all unique. I can either write them out manually or pull the names out by index. I‚Äôll do the latter.</p>
<pre class="r"><code>response = names(dat)[1:3]
expl = names(dat)[4:7]</code></pre>
<p>When I know I‚Äôm going to be looping through character vectors I like to use <em>named</em> vectors to help me keep track of things in the output. The <code>set_names()</code> function in <strong>purrr</strong> is super handy for this, since it can use the values of the vector as names (i.e., the vector will be named by itself). This is great for character vectors but I don‚Äôt recommend trying this with lists of data.frames like I have in the past, since naming a data.frame with a data.frame isn‚Äôt so useful. üòÜ</p>
<pre class="r"><code>response = set_names(response)
response</code></pre>
<pre><code>#   elev   resp   grad 
# &quot;elev&quot; &quot;resp&quot; &quot;grad&quot;</code></pre>
<pre class="r"><code>expl = set_names(expl)
expl</code></pre>
<pre><code>#    slp    lat   long     nt 
#  &quot;slp&quot;  &quot;lat&quot; &quot;long&quot;   &quot;nt&quot;</code></pre>
</div>
<div id="create-a-graphing-function" class="section level1">
<h1><a href="#create-a-graphing-function">Create a graphing function</a></h1>
<p>Since I‚Äôm going to make a bunch of plots that will all have the same form, I can make a function that where only <code>x</code> and <code>y</code> variables vary. In this case I‚Äôm making a function to make plots from a single dataset, so I‚Äôm going to hard-code the dataset into the function. If you have multiple datasets or you are making a function for use across projects you‚Äôll likely want to add the dataset as a function argument.</p>
<p>Since the inputs are based on the variable names, so have to be passed into the <strong>ggplot2</strong> functions as strings. Strings can not be used directly in <code>aes()</code>, but can be directly in <code>aes_string()</code>.</p>
<p>I‚Äôm making a pretty basic graph since there are exploratory plots, not publication ready plots. I will make a scatterplot and add locally weighted regression (loess) lines via <code>geom_smooth()</code>. I use such lines with great caution, as it can be easy to get too attached to what the loess line shows.</p>
<pre class="r"><code>scatter_fun = function(x, y) {
     ggplot(dat, aes_string(x = x, y = y) ) +
          geom_point() +
          geom_smooth(se = FALSE, color = &quot;grey74&quot;) +
          theme_bw()
}</code></pre>
<p>Here‚Äôs an example of the function output, passing in <code>x</code> and <code>y</code> as strings.</p>
<pre class="r"><code>scatter_fun(&quot;lat&quot;, &quot;elev&quot;)</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p><em>Aside</em>: The <code>aes_string()</code> function has been soft deprecated as of <strong>ggplot2</strong> 3.0.0 and <strong>tidyeval</strong> methods are now available. For basic functions like mine this new framework is pretty straightforward to use. However, right or wrong, I‚Äôve been hesitant to send code that contains tidyeval code to the beginner R users I generally work with on these tasks. I think the code looks complicated and ‚Äúscary‚Äù compared to using <code>aes_string()</code>; I may change my mind with time.</p>
<p>To be thorough, here is an example of the same function using <strong>tidyeval</strong>. I use <code>sym()</code> instead of <code>quo</code> because the inputs are strings.</p>
<p>The output graphic is the same.</p>
<pre class="r"><code>scatter_fun2 = function(x, y) {
     ggplot(dat, aes(x = !!sym(x), y = !!sym(y) ) ) +
          geom_point() +
          geom_smooth(se = FALSE, color = &quot;grey74&quot;) +
          theme_bw()
}

scatter_fun2(&quot;lat&quot;, &quot;elev&quot;)</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
</div>
<div id="looping-through-one-vector-of-variables" class="section level1">
<h1><a href="#looping-through-one-vector-of-variables">Looping through one vector of variables</a></h1>
<p>One way to use this function is to loop through each explanatory variable for a fixed response variable. I will use <code>map()</code> from package <strong>purrr</strong> to loop through the explanatory variables.</p>
<p>I pass each explanatory variable to the first argument in <code>scatter_fun()</code> and I fix the second argument to <code>&quot;elev&quot;</code>. I use the formula coding in <code>map()</code> and so refer to the element of the explantory vector via <code>.x</code>.</p>
<pre class="r"><code>elev_plots = map(expl, ~scatter_fun(.x, &quot;elev&quot;) )</code></pre>
<p>The output is a list of 4 plots (since there are four explanatory variables). You‚Äôll notice that each element of the list has the variable name associated with it. This is why I used <code>set_names()</code> earlier, since this is convenient for printing the plots and, you‚Äôll see later, is convenient when saving the plots to files with understandable names.</p>
<pre class="r"><code>elev_plots</code></pre>
<pre><code># $slp</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<pre><code># 
# $lat</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-10-2.png" width="672" /></p>
<pre><code># 
# $long</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-10-3.png" width="672" /></p>
<pre><code># 
# $nt</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-10-4.png" width="672" /></p>
</div>
<div id="looping-through-both-vectors" class="section level1">
<h1><a href="#looping-through-both-vectors">Looping through both vectors</a></h1>
<p>For only a few response variables we could easily copy and paste the code, changing the hard-coded response variable each time. This process can get burdensome of there are a lot of response variables, though.</p>
<p>It is possible to loop through both vectors of variables. Because we want a plot for each combination of variables, this is a job for a <em>nested</em> loop. This means I will do one <code>map()</code> loop inside another. I will refer to the first <code>map()</code> as the <em>outer</em> loop and the second one as the <em>inner</em> loop.</p>
<p>The nested loop leads to more complicated code. I found it takes more work to understand how to refer to the list element from the outer loop within the inner loop if I want to stick to using the <code>map()</code> formula coding I used above. I found the answers/comments to <a href="https://stackoverflow.com/questions/48847613/purrr-map-equivalent-of-nested-for-loop">this question</a> on Stack Overflow helpful in understanding how to approach nested loops via <code>map()</code>. One approach is to avoid the formula coding all together and use anonymous functions for either or both the inner and outer loops.</p>
<p>I‚Äôm going to have the response variables in the outer loop and the explanatory variables in the inner loop. That way I graph all of the explanatory variables for each response variable before moving on to the next response variable. This puts the output, a nested list, in a logical order.</p>
<p>Since my scatterplot function is simple, I ended up using formula coding for the outer loop and the function as is in the inner loop. The inner list elements are fed to the first argument of <code>scatter_fun()</code> (which works great since the first argument is for the <code>x</code> variables). The <code>.x</code> then refers to the outer list elements, which are passed to the <code>y</code> argument in the inner loop.</p>
<pre class="r"><code>all_plots = map(response,
                ~map(expl, scatter_fun, y = .x))</code></pre>
<p>The output is a list of lists. Each sublist is all the plots for a single response variable. Because I set the names for the two vectors of variable names, both the inner and outer lists have names. These can be used to pull out individual plots.</p>
<p>For example, if I want to see all the plots for the <code>grad</code> response variable I can print that sublist by name. (I‚Äôm going to show only two of four <code>grad</code> plots here to save space.)</p>
<pre class="r"><code>all_plots$grad</code></pre>
<pre><code># $slp</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-13-1.png" width="576" /></p>
<pre><code># 
# $lat</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-13-2.png" width="576" /></p>
<p>If I want to see a single plot, I can first extract one of the sublists using one of the outer list names and then extact the individual plot via an inner list name.</p>
<pre class="r"><code>all_plots$grad$long</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>I find the names convenient, but you can also extract plost via position. Here‚Äôs the same graph, the third element of the third list.</p>
<pre class="r"><code>all_plots[[3]][[3]]</code></pre>
<pre><code># `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<div id="saving-the-plots" class="section level2">
<h2><a href="#saving-the-plots">Saving the plots</a></h2>
<p>Once we have all the graphs, we can look at them in R by printing the list or parts of the list as above. But if you want to peruse them at your leisure or send them to a collaborator you‚Äôll want to save them outside of R.</p>
<p>This next section is dedicated to exploring some of the ways you can do this.</p>
</div>
<div id="saving-all-plots-to-one-pdf" class="section level2">
<h2><a href="#saving-all-plots-to-one-pdf">Saving all plots to one PDF</a></h2>
<p>If you want to save every plot as a separate page in a PDF, you can do so with the <code>pdf()</code> function. The code below shows how this work. A graphics device to save the plots into is created and given a name via <code>pdf()</code>, all the plots are put into that device, and then the device turned off with <code>dev.off()</code>. The last step is important, as you can‚Äôt open the file until the device is turned off.</p>
<p>I‚Äôd say this is a pretty coarse way to save everything, but it allows you to easily page through all the plots. I‚Äôve used this method when I had many exploratory plots for a single response variable that I wanted to share with collaborators.</p>
<p>In this example code I save the file, which I name <code>all_scatterplots.pdf</code>, into the working directory.</p>
<pre class="r"><code>pdf(&quot;all_scatterplots.pdf&quot;)
all_plots
dev.off()</code></pre>
</div>
<div id="saving-groups-of-plots-together" class="section level2">
<h2><a href="#saving-groups-of-plots-together">Saving groups of plots together</a></h2>
<p>Another option is to save each group of plots to a separate document. This may make sense in a case like this where there are a group of plots for separate response variables so we might want a separate file of plots for each one.</p>
<p>To save each sublist separately we need to loop through <code>all_plots</code> and save the plots for each response variable as a separate file. The list names can be used in the file names.</p>
<p>The functions in <strong>purrr</strong> that start with <code>i</code> are special functions that loop through a list and the names of that list simultaneously. This is a convenient function in a case like this where we want to use the list names to identify the output files.</p>
<p>The <code>walk()</code> function is part of the <code>map</code> family, to be used when you want to use a function for its side effects instead of for the return value. This is exactly what we are doing when looping and saving plots, since our goal is not to make a new list but to save the one we have.</p>
<p>Combining the <code>i</code> and the <code>walk</code> gives us the <code>iwalk()</code> function. In the formula interface, <code>.y</code> refers to the names of the list and <code>.x</code> to the list elements. I create the plot file names using the list name combined with ‚Äúscatterplots.pdf‚Äù.</p>
<p>The code below makes three files, one for each response variable, with four plots each. The files are named ‚Äúelev_scatterplots.pdf‚Äù, ‚Äúresp_scatterplots.pdf‚Äù, and ‚Äúgrad_scatterplots.pdf‚Äù.</p>
<pre class="r"><code>iwalk(all_plots, ~{
     pdf(paste(.y, &quot;scatterplots.pdf&quot;, sep = &quot;_&quot;) )
     print(.x)
     dev.off()
})</code></pre>
</div>
<div id="saving-all-plots-separately" class="section level2">
<h2><a href="#saving-all-plots-separately">Saving all plots separately</a></h2>
<p>All plots can be saved separately instead of combined in a single document. This might be necessary if you need to insert the plots into some larger document later.</p>
<p>We‚Äôll want to use the names of both the outer and inner lists to appropriately identify each plot. I decided to this by looping through <code>all_plots</code> list and the names of the list via <code>imap()</code> to make appropriate file names. This time I‚Äôm going to save these as PNG files so use <code>.png</code> at the end of the file name instead of <code>.pdf</code>.</p>
<p>The result will be a list of lists still, so I flatten it into a single list via <code>flatten()</code>. If I were use <code>flatten()</code> earlier in the process I‚Äôd lose the names in the outer list. This process of combining names will be simplified once <a href="https://github.com/tidyverse/purrr/issues/525">the proposed <code>flatten_names()</code> function</a> is added to <strong>purrr</strong>.</p>
<pre class="r"><code>plotnames = imap(all_plots, ~paste0(.y, &quot;_&quot;, names(.x), &quot;.png&quot;)) %&gt;%
     flatten()
plotnames</code></pre>
<pre><code># [[1]]
# [1] &quot;elev_slp.png&quot;
# 
# [[2]]
# [1] &quot;elev_lat.png&quot;
# 
# [[3]]
# [1] &quot;elev_long.png&quot;
# 
# [[4]]
# [1] &quot;elev_nt.png&quot;
# 
# [[5]]
# [1] &quot;resp_slp.png&quot;
# 
# [[6]]
# [1] &quot;resp_lat.png&quot;
# 
# [[7]]
# [1] &quot;resp_long.png&quot;
# 
# [[8]]
# [1] &quot;resp_nt.png&quot;
# 
# [[9]]
# [1] &quot;grad_slp.png&quot;
# 
# [[10]]
# [1] &quot;grad_lat.png&quot;
# 
# [[11]]
# [1] &quot;grad_long.png&quot;
# 
# [[12]]
# [1] &quot;grad_nt.png&quot;</code></pre>
<p>With the file names created I can loop through all the plots and the file names simultaneously and save things via <code>ggsave()</code>. The height and width of each output file can be set as needed.</p>
<p>I flatten the nested list of plots to loop through it and the file names simultaneously in <code>walk2()</code> and save each plot in a separate file.</p>
<pre class="r"><code>walk2(flatten(all_plots), plotnames, ~ggsave(filename = .y, plot = .x, 
                                         height = 7, width = 7))</code></pre>
</div>
<div id="combining-plots" class="section level2">
<h2><a href="#combining-plots">Combining plots</a></h2>
<p>Another way to get all the plots together, depending on how many you have per response variable, is to combine them into one plot. This is a lot like faceting, except we didn‚Äôt reshape our dataset to allow the use faceting.</p>
<p>I like the <strong>cowplot</strong> function <code>plot_grid()</code> for combining multiple plots into one. A list of plots can be passed via the <code>plotlist</code> argument.</p>
<p>Here‚Äôs what that looks like for the first response variable, <code>elev</code>.</p>
<pre class="r"><code>cowplot::plot_grid(plotlist = all_plots[[1]])</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>We can use a loop to do this for all the sublists, shown below, which could then be saved using any of the approaches shown above.</p>
<pre class="r"><code>response_plots = map(all_plots, ~cowplot::plot_grid(plotlist = .x))
response_plots</code></pre>
<pre><code># $elev</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<pre><code># 
# $resp</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-21-2.png" width="672" /></p>
<pre><code># 
# $grad</code></pre>
<p><img src="/post/2018-08-16-automating-exploratory-plots_files/figure-html/unnamed-chunk-21-3.png" width="672" /></p>
</div>
</div>
