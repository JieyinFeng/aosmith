---
title: Converting from binomial to binary 0/1 with purrr::pmap()
author: Ariel Muldoon
date: '2019-10-04'
slug: converting-binomial-to-binary
categories:
  - r
  - statistics
tags:
  - data
  - purrr
  - glmm
description:  I show how binomial count data can be expanded to long-form binary 0/1 data.  I've used this in simulations to explore how to diagnose lack of fit when there is known extra-binomial variation when analyzing binary data.
---

```{r setup, include = FALSE, message = FALSE, purl = FALSE}
knitr::opts_chunk$set(comment = "#")
devtools::source_gist("2500a85297b742c6f2fb3a14549f5851",
                      filename = 'render_toc.R')

# Make small binomial dataset for 2 groups
     # Total number of trials varies
set.seed(16)
sampsize = sample(5:10, size = 8, replace = TRUE) # sample size
x1 = rbinom(n = 4, size = sampsize[1:4], p = 0.75) # group 1
x2 = rbinom(n = 4, size = sampsize[5:8], p = 0.25) # group 2

dat = data.frame(plot = paste0("plot", 1:8),
                 group = rep( c("g1", "g2"), each = 4),
                 resp = c(x1, x2),
                 total = sampsize)
```

Data on successes and failures can be summarized and analyzed as counted proportions via the binomial distribution or as long format 0/1 binary data.  I most often see summarized data when there are multiple trials done within a study unit; for example, when tallying up the number of dead trees out of the total number of trees in a plot.  

If these within-plot trials are all independent, analyzing data in a binary format instead of summarized binomial counts doesn't change the results.  If trials are not independent, though, neither approach works correctly.  The confusing piece in this is that binary data [by definition can't be overdispersed](https://stat.ethz.ch/pipermail/r-sig-mixed-models/2011q1/015534.html) and so the lack of fit from non-independence can't be diagnosed with standard overdispersion checks when working with binary data.

In a future post I'll talk more about simulating data to explore binomial overdispersion and how lack of fit can be diagnosed in binomial vs binary datasets.  Today, however, my goal is show how to take binomial count data and expand it into binary data.  

In the past I've done the data expansion with `rowwise()` and `do()` from package **dplyr**, but these days I'm using `purrr::pmap()`.  I'll demonstrate the `pmap()` approach as well as a nesting approach with `nest()`/`unnest()` from **tidyr**.

## Table of Contents

```{r toc, echo = FALSE, purl = FALSE} 
input  = knitr::current_input()
render_toc(input)
```

# Load R packages

I'm using **purrr** for rowwise loops with `pmap_dfr()`.  I also load **dplyr** and **tidyr** for a `nest()`/`unnest()` approach.

```{r, message = FALSE, warning = FALSE}
library(purrr) # 0.3.2
library(tidyr) # 1.0.0
library(dplyr) # 0.8.3
```

# The dataset

I created a dataset from a total of 8 plots, 4 plots in each of two groups.  The number of trials (`total`) per plot varied.  The number of successes observed is in `resp`.

```{r}
dat = structure(list(plot = structure(1:8, .Label = c("plot1", "plot2", 
"plot3", "plot4", "plot5", "plot6", "plot7", "plot8"), class = "factor"), 
    group = structure(c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L), .Label = c("g1", 
    "g2"), class = "factor"), resp = c(4L, 6L, 6L, 5L, 1L, 4L, 
    3L, 2L), total = c(5L, 7L, 9L, 7L, 8L, 10L, 10L, 7L)), class = "data.frame", row.names = c(NA, 
-8L))

dat

```

# Expanding binomial to binary with pmap_dfr()

To make the binomial data into binary data, I need to make a vector with a 1 for every success listed in `resp` and a 0 for every failure (the total number of trials minus the number of successes).  I need this for every row in the dataset.  Since I want to do a *rowwise* operation I'll use one of the `pmap` functions.  I want my output to be a dataset so I use `pmap_dfr()`.

I use an anonymous function within `pmap_dfr()` for creating the output I want from each row. I purposely make the names of the function arguments match the column names.  You can either match on position or on names in `pmap` functions, and I generally like to match on names.  You can use formula coding with the tilde in `pmap` variants, but I find this more difficult to understand when I have more than three or so columns.  

Within the function I make a column for the response variable, repeating 1 `resp` times and 0 `total - resp` times for each row of the original data.  I'm taking advantage of [recycling](http://www.hep.by/gnu/r-patched/r-lang/R-lang_41.html) in `data.frame()` to keep the `plot` and `group` columns in the output, as well.

```{r}
binary_dat = pmap_dfr(dat, 
                      function(group, plot, resp, total) {
                           data.frame(plot = plot,
                                      group = group,
                                      resp = c( rep(1, resp),
                                                rep(0, total - resp) ) )
                      }
)
```

Here are the first 6 rows of the dataset.  You can see for the first plot, `plot1`, there are five rows of 1 and 1 row with 0.  

```{r}
head(binary_dat)
```

This is the expanded data from the first row of the original dataset.

```{r}
dat[1, ]
```

# Aside: pmap() with more columns

My anonymous function in `pmap_dfr()` works fine as is as long as every column is included as a function argument.  If I had extra columns that I didn't want to remove and wasn't using in the function, however, I would get an error.  To bypass this you can add dots, `...`, to the anonymous function to refer to all other columns not being used.  

```{r, eval = FALSE}
function(group, plot, resp, total, ...)
     
```

# Comparing analysis results

While I definitely learned that binomial data can be analyzed in binary format in a GLM class and returns identical, for some reason I often have to re-convince myself this is true. `r emo::ji("stuck_out_tongue_winking_eye")` This is clear when I do an analysis with each dataset and compare results.

## Binomial model

Here's results from comparing the two groups for the binomial model.

```{r}
fit = glm( cbind(resp, total - resp) ~ group, 
           data = dat,
           family = binomial)

summary(fit)$coefficients

```

## Binary model

The binary model gives identical results for estimates and statistical tests.

```{r}
fit_binary = glm( resp ~ group, 
                  data = binary_dat,
                  family = binomial)

summary(fit_binary)$coefficients

```

# Expanding binomial to binary via nesting

I could do the same thing with nesting plus `map()` inside `mutate()`, although this seems less straightforward to me for this particular case.  It does keep the other variables in the dataset, though, without having to manually include them in the output data.frame like I did above.

```{r}
binary_dat2 = dat %>%
     nest(data = c(resp, total) ) %>%
     mutate(resp = map(data, ~c( rep(1, .x$resp),
                                 rep(0, .x$total - .x$resp) ) )
     ) %>%
     select(-data) %>%
     unnest(resp)
head(binary_dat2)
```

# Just the code, please

```{r getlabels, echo = FALSE, purl = FALSE}
labs = knitr::all_labels()
labs = labs[!labs %in% c("setup", "toc", "getlabels", "allcode", "makescript")]
```

```{r makescript, include = FALSE, purl = FALSE}
options(knitr.duplicate.label = "allow") # Needed to purl like this
input  = knitr::current_input()  # filename of input document
scriptpath = paste(tools::file_path_sans_ext(input), "R", sep = ".")
output = here::here("static", "script", scriptpath)
knitr::purl(input, output, documentation = 0, quiet = TRUE)
```

Here's the code without all the discussion.  Copy and paste the code below or you can download an R script of uncommented code [from here](`r paste0("/script/", scriptpath)`).

```{r allcode, ref.label = labs, eval = FALSE, purl = FALSE}
```
