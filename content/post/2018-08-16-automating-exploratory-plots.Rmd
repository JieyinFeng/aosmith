---
title: Automating exploratory plots with ggplot2 and purrr
author: Ariel Muldoon
date: '2018-08-16'
slug: automating-exploratory-plots
categories:
  - r
tags:
  - ggplot2
  - purrr
draft: TRUE
description: "Here I show an example of how to automate the process of making many exploratory plots in ggplot2 with multiple continuous response and explanatory variables.  To loop through both x and y variables involves nested looping.  I end the post talking about some options for saving the results, either individually in a single document, separately, or by stitching plots together prior to saving."
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(comment = "#")
```

# Load R packages

I'll be plotting with **ggplot2** and doing looping with **purrr**.  I'll also be using package **cowplot** later to stitch together plots, but won't load it since it changes the theme in **ggplot2**.

```{r}
library(ggplot2) # v. 3.0.0
library(purrr) # v. 0.2.5
```

# The set-up

Today I'm going to make an example dataset with 3 response (y) variables and 4 explanatory (x) variables.

```{r}
set.seed(16)
dat = data.frame(elev = round( runif(20, 100, 500), 1),
                 resp = round( runif(20, 0, 10), 1),
                 grad = round( runif(20, 0, 1), 2),
                 slp = round( runif(20, 0, 35),1),
                 lat = runif(20, 44.5, 45),
                 long = runif(20, 122.5, 123.1),
                 nt = rpois(20, lambda = 25) )
head(dat)
```

As you can see, every variable is in a separate column.  The goal is to make scatterplots for every response variable vs every explanatory variable, where I've deemed the first three in the dataset to be the response variables.

In order to automate things I'm going to need vectors of the variable names to loop through, one for the response and one for the explanatory.  If all of your variables share some unique names there are some clever ways to pull out the names of only those variables with some of the select helper functions in `dplyr::select()`.  Alas, mine are all unique.  I can either write them out manually or pull the names out by index.  I'll do the latter.

```{r}
response = names(dat)[1:3]
expl = names(dat)[4:7]
```

When I know I'm going to be looping through character vectors I like to use *named* vectors to help me keep track of things.  The `set_names()` function in **purrr** is super handy for this, since it will use the values of the vector as names if you don't supply them (i.e., the vector will be named by itself).  This is great for character vectors but I don't recommend trying this with lists of data.frames like I did, since naming a data.frame with a data.frame just isn't so useful.  `r emo::ji("laughing")`

```{r}
response = set_names(response)
response
```

```{r}
expl = set_names(expl)
expl
```

# [Create a graphing function](#create-a-graphing-function)

Since I want a bunch of different plots that nominally have the same form, I can make a function that takes the `x` and `y` variables as inputs.  In this case I'm making a function to do the work on a single dataset, so the dataset is hard-coded into the function.  If you have multiple datasets or you are making a function for use across projects you'll probably want to use that as a function argument, instead. 

Because the inputs are based on the names, these are strings.  We can use strings in **ggplot2** by using `aes_string()`.

I'm making a pretty basic graph here since there are exploratory plots.  I'm going to add the points as well as a loess line (I use such lines with great caution, as it can be easy to get too attached to what a locally weighted regression line shows).

```{r}
scatter_fun = function(x, y) {
     ggplot(dat, aes_string(x = x, y = y) ) +
          geom_point() +
          geom_smooth(se = FALSE, color = "grey74") +
          theme_bw()
}
```

Here's an example of the output, passing in `x` and `y` as strings.  (What a great example of how small samples can demonstrate strong patterns even when we know the variables aren't related!).

```{r, message = FALSE}
scatter_fun("elev", "lat")
```

*Aside*:  The `aes_string()` function has been soft deprecated as of **ggplot2** 3.0.0 and the **tidyeval** methods are now available.  For basic functions like mine this new framework is pretty straightforward to use.  However, right or wrong, I've been hestiant to send code that contains it to the beginner R users I work with.  I think the code looks comparatively complicated and "scary" looking compared to using `aes_string()`.

To be thorough, below is an example of the same function using **tidyeval**.  The output graphic is the same.

```{r, message = FALSE}
scatter_fun2 = function(x, y) {
     ggplot(dat, aes(x = !!sym(x), y = !!sym(y) ) ) +
          geom_point() +
          geom_smooth(se = FALSE, color = "grey74") +
          theme_bw()
}

scatter_fun2("elev", "lat")
```

# [Looping through one vector of variables](#looping-through-one-vector-of-variables)

One way to use this function is to fix the response variable and loop through the explanatory variables, making a plot for each one.  That way each response variable has a separate list as output.

I will use `map()` from package **purrr** to loop through each explanatory variable and plot it.  I'll fix the response variable to `elev`.

```{r}
elev_plots = map(expl, ~scatter_fun(.x, "elev") )
```

This makes four plots, one for each explanatory variable.  You'll notice that each element of the list (so each plot) has a variable name associated with it.  This is why I used `set_names()` earlier, because this is convenient for printing and, you'll see later, is convenient when saving the plots with useful names.

```{r, message = FALSE}
elev_plots
```

# [Looping through both vectors](#looping-through-both-vectors)

The work above works well for only a few response variables.  But it still involves using the same code for each set of plots, which can get burdensome of there are a lot of response variables. 

It is possible to loop through both vectors of variables.  Because we want a plot for each combination of variables, this is a job for a *nested* loop.  This means I will do one `map()` loop inside another.

The code gets more complicated.  If using the formula coding like I did above, I found it takes more work to understand how to refer to the variable in the outer loop within the inner loop.  The answers to [this question](https://stackoverflow.com/questions/48847613/purrr-map-equivalent-of-nested-for-loop) on Stack Overflow were useful for this (including some of the comments to answers).  One approach is to avoid the formula coding all together and use anonymous functions for either or both inner and outer loops.

I loop first through the response variables and make graphs with all of the explanatory variables for each one with the nested inner loop.  This puts the output, a nested list, in a convenient order.

Since my scatterplot function is simple, I ended up using formula coding for the outer loop and simply listed the function in the inner loop.  The inner list elements are then fed to the first argument in `scatter_fun()` (which makes sense since these are the `x` variables).  The `.x` then refers to the outer list elements, and this is passed to the `y` argument in the second `map()`.

```{r}
all_plots = map(response,
                ~map(expl, scatter_fun, y = .x))
```

The output is a list of lists.  Each sublist is all the plots for a single response variable (remember, I planned things this way).  Because I set the names on the two vectors, both the inner and outer lists have names.  

For example, if I want to see all the plots for the `grad` response variable I can print that sublist by name.  (I'm going to show only two of four `grad` plots here to save space.)

```{r, eval = FALSE}
all_plots$grad
```

```{r, echo = FALSE, message = FALSE, message = FALSE, fig.height = 4, fig.width = 6}
all_plots$grad[1:2]
```

If I want to see a single plot, I can also use the names to extract it.

```{r, message = FALSE}
all_plots$grad$long
```

I find the names convenien, but I can always extract via position, as well.  Here's the same graph as above.

```{r}
all_plots[[3]][[3]]
```

## [Saving the plots](#saving-the-plots)

Once you have all the graphs, you can print them to your console by running the list name to look at them.  But if you want to puruse them at your leisure or send them to a collaborator you'll want to save them.  This next section is dedicated to exploring some of the ways you can do this.

## [Saving all plots to one PDF](#saving-all-plots-to-one-pdf)

If you want to save every plot as a separate page in a PDF, you can do so with the `pdf()` function.  The code below shows that the plot must be initialized, then all plots put in it, and then the device turned off.  If you skip the last step you won't be able to open the output document.  

This is a coarse way to save everything, but also allows you to easily page through all the plots and revisit as necessary.  I've found this useful when I had many exploratory plots that I wanted to share with collaborators.

In this example code I save the file I name `all_scatterplots` into the working directory.

```{r, eval = FALSE}
pdf("all_scatterplots.pdf")
all_plots
dev.off()
```

## [Saving groups of plots together](#saving-groups-of-plots-together)

Another option, for organization, is to save each group of plots to a separate list.  This may make sense in this case where there are separate response variables to think about.

To save each sublist separately we need to loop through `all_plots` and save it into a separate file.  The list names can be used in the plot names.  

The functions in **purrr** that start with `i` are special functions that loop through a list and the names of the list simultaneously, which is handy for a case like this where we have names to identify the plots.

The `walk()` function is part of the `map` family of functions uses the function only for the side effect.  This is what we want for saving plots, since our goal is not to output a new list but simply save the one we have.

Combining the `i` and the `walk` gives as the `iwalk()` function.  In the formula function interface, `.y` refers to the names of the list and `.x` to the list elements.  I create the plot file names using the list name combined with "scatterplots.pdf".

```{r, eval = FALSE}
iwalk(all_plots, ~{
     pdf(paste(.y, "scatterplots.pdf", sep = "_") )
     print(.x)
     dev.off()
})
```

## [Saving all plots separately](#saving-all-plots-separately)

We'd need to use the names in both the outer and inner lists to appropriately identify each plot.  I decided to this by looping through `all_plots` and the names of the list via `imap()` to create names.  This time I'm going to save these as PNG files.

The result will be a list of lists still, so I flatten the list into a single list via `flatten()`.  If I use `flatten()` earlier I lose the names in the outer list.  This process of combining names will be simplified once [the proposed `flatten_names()` function](https://github.com/tidyverse/purrr/issues/525) is added to **purrr**.

```{r}
plotnames = imap(all_plots, ~paste0(.y, "_", names(.x), ".png")) %>%
     flatten()
plotnames
```

With the file names created I can loop through all the plots and the file names simultaneously and save things via `ggsave()`.  The height and width of each output file can be set.

I flatten the nested list of plots to loop through it and the file names simultaneously in `walk2()` and save each plot in a separate file.

```{r, eval = FALSE}
walk2(flatten(all_plots), plotnames, ~ggsave(filename = .y, plot = .x, 
                                         height = 7, width = 7))
```

## [Stitching plots together in groups](#stitching-plots-together-in-groups)

Another way to get all the plots together, depending on how many you have per response variable, is to stitch them into one plot.  This is like faceting except we didn't reshape our dataset to use faceting.  I like **cowplot** for this, as a list of plots can be passed via the `plotlist` argument.

Here's what that looks like for the first response variable, `elev`.

```{r, message = FALSE}
cowplot::plot_grid(plotlist = all_plots[[1]])
```

We can use a loop to do this for all the sublists, shown below, which could then be saved in any of the way shown above.

```{r, message = FALSE}
map(all_plots, ~cowplot::plot_grid(plotlist = .x))
```
