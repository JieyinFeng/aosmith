---
title: Making many added variable plots with purrr and ggplot2
author: Ariel Muldoon
date: '2018-01-31'
slug: added-variable-plots
categories:
  - r
  - statistics
tags:
  - ggplot2
draft: TRUE
description: "In this post I show one approach for making added variable plots from a model with many continuous explanatory variables.  Since this is done for every variable in the model, I show how to automate the process via functions from package purrr." 
---

Last week two of my consulting meetings ended up covering the same topic:  making added variable plots.

In both cases, the student had a linear model of some flavor that had several continuous explanatory variables.  This is the kind of situation where students could end up doing a lot of copying and pasting to make added variable plots for each explanatory variable.  Because of this I decided to write up an example of how they might automate the task with functions and loops to make an added variable plot for each explanatory variable in the model.

# The basics of added variable plots

Added variable plots (aka partial regression plots, adjusted variable plots, individual coefficient plots), are what I would call "results" plots.  These are plots showing the estimated relationship between the response and an explanatory variable *after accounting for the other variables in the model*.  If working with only two explanatory variables, a 3-dimensional plot could be used in place of the added variable plot (if one liked those sorts of plots).  But once there are many variables in the model we don't have enough plotting dimensions to show how all the variables relate to the response simultaneously and so added variable plots are an option.

Added variable plots can be made using, e.g., the **effects** package in R.  I've found this package to have matured nicely, and I think the plots look pretty nice.  However, I often like more flexibility, which I can get by making my own plots.  This involves getting appropriate predictions and confidence intervals from the model.  

For making an added variable plot, it is fairly standard to make the predictions with all other variables fixed to their medians or means.  Note that in my example I'm talking about the relatively simple case where there are no interactions between continuous variables in the model. That would involve a more complicated set-up.

# R packages

The main workhorses I'm using today is **purrr** for looping through variables/lists and **ggplot2** for plotting.  But I also use helper functions from **dplyr** for data manipulation and **broom** for making model predictions.

```{r}
library(dplyr) # v. 0.7.4
library(ggplot2) # v. 2.2.1.9000
library(purrr) # v. 0.2.4
library(broom) # v. 0.4.3
```

# The model

I'll show an example for fitting a linear model with a transformed response variable in `lm()`, but the process works the same for generalized linear models fit with `glm()` and would be very similar for other linear models.

My linear model is based on five continuous variable from the *mtcars* dataset.  (*I know, I know, that dataset has been incredibly overused.  I seriously looked around for another dataset to use (that wasn't a time series) that had many continuous explanatory variables in it but didn't come up with anything.  If you know of one, let me know!*)

The model I fit uses a log transformation for the response variable, so predictions and confidence interval limits will need to be back-transformed for plotting.

```{r}
fit1 = lm( log(mpg) ~ disp + hp + drat + wt, data = mtcars)
summary(fit1)
```

# The explanatory variables

The approach I'm going to take is to loop through the explanatory variables in the model, following the same process for each one so I end up with an added variable plot per variable.

I could write out a vector of variable names manually, but I prefer to pull them out of the model.  In the approach I used the first variable is the response variable, which I don't need and so I remove it.

```{r}
( mod_vars = all.vars( formula(fit1) )[-1] )
```

# A function for making a prediction dataset

The first step in making an added variable plot manually is to create the dataset for making the predictions. This dataset will contain the observed data for the explanatory variable of interest (which I'll call the "focus" variable) with all other variables fixed to their medians (or means if you prefer).  

Below is a function for doing this task.  The function takes a dataset, a vector of the variables in the model (as strings), and the explanatory variable of interest (as a string).  The **dplyr** \*_at() functions can take strings as input, so I use `summarise_at()` to calculate the medians of the non-focus variables and then bind them with the values of the focus variable from the original dataset.  The `cbind()` functions is handy here because it allows recycling.

```{r}
preddat_fun = function(data, allvars, var) {
     sums = summarise_at(data, 
                         vars( one_of(allvars), -one_of(var) ), 
                         median) 
     cbind( select_at(data, var), sums)
}
```

Here's what the result of the function looks like for a single focus variable, "disp" (top six rows).

```{r}
head( preddat_fun(mtcars, mod_vars, "disp") )
```

# Making a prediction dataset for each variable

Now that I have a working function I can loop through each variable in the "mod_vars" vector and create the prediction dataset.  I'll use `map()` from **purrr** for this.  I use `set_names()` prior to the loop so each dataset will be labeled with the variable name.

The result is a list of prediction datasets.

```{r}
pred_dats = mod_vars %>%
     set_names() %>%
     map( ~preddat_fun(mtcars, mod_vars, .x) )
str(pred_dats)
```

# Calculate model predictions

Once the prediction datasets are created, the predictions can be calculated and added to each one  I do this on the model scale, since I want to make confidence intervals with the standard errors prior to back-transforming.

The `augment()` function from **broom** works with a variety of model objects, including *lm* and *glm* objects.  It can take new datasets for prediction with the "newdata" argument.

This step can be done by looping through the prediction datasets, first to add the predictions and then to calculate the approximate confidence intervals and back-transform the predictions and confidence interval limits to the original data scale.

```{r}
preds = pred_dats %>%
     map(~augment(fit1, newdata = .x) ) %>%
     map(~mutate(.x, 
                 lower = exp(.fitted - 2*.se.fit),
                 upper = exp(.fitted + 2*.se.fit),
                 pred = exp(.fitted) ) )
```

Here is what the structure of the list elements look like now (showing only the first list).

```{r}
str(preds$disp)
```


# A function for plotting

With the predictions done, it's time for plotting.  If each plot is going to look really different, the plots could be made individually.  However, if they will all have a similar look then it can be worthwhile to make a function for plotting. 

I don't spend a bunch of time making the plots look really nice in my plotting function for this example, but the point of building these plots based on predictions instead of having a plotting package to the work is for the flexibility of making them look exactly how you want them.

One problem I anticipate running into in automating the plotting is with the x axis labels.  If I want to the x axis names to look nicer than the variable names I'll need to make a vector of labels.  This needs to be in the same order as the vector of variable names and the list of prediction datasets.

```{r}
xlabs = c("Displacement (cu.in.)", "Gross horsepower",
          "Rear axle ratio", "Weight (1000 lbs)")
```

My plotting function has three arguments: the dataset to plot, the explanatory variable to plot on the x axis (as a string), and label for the x axis (also as a string).

```{r}
pred_plot = function(data, variable, xlab) {
     ggplot(data, aes_string(variable, "pred") ) +
          geom_line(size = 1) +
          geom_ribbon(aes(ymin = lower, ymax = upper), alpha = .25) +
          theme_bw() +
          labs(x = xlab,
               y = "Miles/(US) gallon") +
          ylim(10, 32)
}
```

And a plot for the "disp" variable, which is the first element of the three lists (prediction dataset, variables, axis labels).

```{r}
pred_plot(preds[[1]], mod_vars[1], xlabs[1])
```

# Making all the plots

The last step is to make all the plots.  Because we want to loop through three different lists (the prediction datasets, the variable names, and the axis labels), this can be a done via `pmap` from **purrr**.

```{r}
all_plots = pmap( list(preds, mod_vars, xlabs), pred_plot)
all_plots
```

## Using the plots

The plots can be printed all at once as above or individually using indexes or list names, with code like `all_plots[[1]]` or `all_plots$disp`.  Plots can also be saved for use outside of R; for saving individual plots you might use a `walk()` loop.

I could see there being interest in combining these into a multi-plot.  A faceted plot would be an option, but the approach I've done here in its current form isn't a great one for using faceting instead of making individual plots (although I'm sure it could likely be modified with that in mind).  

The individual plots can be combined into a single figure via **cowplot** functions, though, without too much trouble.  Note that **cowplot** is opinionated about the theme, so I use it without loading it.

The `plot_grid()` function can take a list of plots and has a variety of options you might want to explore.

```{r}
cowplot::plot_grid(plotlist = all_plots,
          labels = "AUTO",
          align = "hv")
```
